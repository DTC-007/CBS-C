#include <stdio.h>

void ex1();   //
void ex2();   //两种数组表示法
void ex3();   //各种表达式
void ex4();   //指针自增减
void ex5();   //多维数组


int main() {
    ex1();
    ex2();
//    ex3();
    ex4();
    ex5();
}

void ex1() {
    char str[] = "Hello World!";
    char * p = str;   //？？？啥情况，为什么能直接把数组作为地址赋值给指针变量p？？？

    printf("%c ", *p);   //还能正常使用，打印出第一个字符？？？
    printf("%c", p[0]);   //？？？怎么像在使用数组一样用指针？？？

    printf("\n\n");
}

void ex2() {        //两种数组表示法
    //数组表示法
    char str[] = "Hello World!";
    printf("%c ", str[0]);   //直接在中括号中输入对应的下标就能访问对应位置上的数组了

    //指针表示法
    char * p = str;
    printf("第一个元素值为：%c，第二个元素值为：%c", *p, *(p+1));   //通过指针也可以表示对应位置上的值
    //*(p+i)   <=>    str[i]
    printf("\n\n");
}

void ex3() {        //各种表达式
//    *p;   //数组的第一个元素
//    p   //数组的第一个元素的地址
//    p == str   //肯定是真，因为都是数组首元素地址
//    *str    //因为str就是首元素的地址，所以这里对地址加*就代表第一个元素，使用的是指针表示法
//    &str[0]   //这里得到的实际上还是首元素的地址
//    *(p + 1)   //代表第二个元素
//    p + 1    //第二个元素的内存地址
//    *p + 1    //注意*的优先级比+要高，所以这里代表的是首元素的值+1，得到字符'I'
}

void ex4() {        //指针自增减
    char str[] = "Hello World!";
    char * p = str;

    p++;  //自增后相当于指针指向了第二个元素的地址
    p--;

    printf("%c", *p);   //所以这里打印的就是第二个元素的值了

    printf("\n\n");
}

void ex5() {        //多维数组
    int arr[2][3] = {{1, 2, 3}, {4, 5, 6}};
    int * p = arr[0];  //因为是二维数组，注意这里要指向第一个元素，来降一个维度才能正确给到指针
    //同理如果这里是arr[1]的话那么就表示指向二维数组中第二个数组的首元素
    printf("%d = %d", *(p + 4), arr[1][1]);   //实际上这两种访问形式都是一样的
}